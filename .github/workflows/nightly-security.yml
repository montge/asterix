name: Nightly Security Scans

on:
  schedule:
    - cron: '0 2 * * *'  # 2 AM UTC daily
  workflow_dispatch:  # Allow manual trigger

permissions:
  contents: read
  issues: write

jobs:
  rust-miri:
    name: Miri (Undefined Behavior Detection)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly
        with:
          components: miri

      - name: Run Miri
        id: miri
        working-directory: asterix-rs
        run: |
          # Miri cannot test FFI-calling code, so we skip integration tests
          # Run unit tests only (--lib) which are pure Rust without FFI
          cargo +nightly miri test --lib

      - name: Create issue on failure
        if: failure() && steps.miri.outcome == 'failure'
        uses: actions/github-script@v8
        with:
          script: |
            const title = '[Nightly] Miri detected undefined behavior';
            const body = `Miri scan failed on ${new Date().toISOString().split('T')[0]}.

            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            This indicates potential undefined behavior in the Rust FFI layer. Please review the workflow logs for details.

            **Priority:** High - undefined behavior can cause crashes or security vulnerabilities.`;

            // Check if issue already exists
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,miri'
            });

            const existingIssue = issues.data.find(i => i.title === title);

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['security', 'rust', 'miri', 'automated']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Still failing as of ${new Date().toISOString().split('T')[0]}.\n\n**Latest run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
              });
            }

  python-valgrind:
    name: Valgrind (Memory Leak Detection)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y valgrind libexpat1-dev cmake

      - name: Build Python module
        run: |
          pip install --upgrade pip setuptools wheel
          python3 setup.py build_ext --inplace

      - name: Install pytest
        run: pip install pytest pytest-cov

      - name: Run Valgrind tests
        id: valgrind
        run: |
          valgrind --leak-check=full --show-leak-kinds=all \
            --error-exitcode=1 --suppressions=.valgrind.supp \
            python3 -m pytest asterix/test/test_ffi_security.py -v

      - name: Create issue on failure
        if: failure() && steps.valgrind.outcome == 'failure'
        uses: actions/github-script@v8
        with:
          script: |
            const title = '[Nightly] Valgrind detected memory leaks';
            const body = `Valgrind scan failed on ${new Date().toISOString().split('T')[0]}.

            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            Memory leaks detected in the Python FFI layer. Please review the workflow logs for details.

            **Priority:** Medium - memory leaks can cause resource exhaustion over time.`;

            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,valgrind'
            });

            const existingIssue = issues.data.find(i => i.title === title);

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['security', 'python', 'memory-leak', 'valgrind', 'automated']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Still failing as of ${new Date().toISOString().split('T')[0]}.\n\n**Latest run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
              });
            }

  python-asan:
    name: ASAN (Address Sanitizer)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y libexpat1-dev cmake clang

      - name: Build with ASAN
        run: |
          pip install --upgrade pip setuptools wheel
          # Set both CC and CXX to clang/clang++ for ASAN instrumentation
          # ASAN flags must be applied to both C/C++ compilation and linking
          CC=clang \
          CXX=clang++ \
          CFLAGS="-fsanitize=address -fno-omit-frame-pointer -g -shared-libasan" \
          CXXFLAGS="-fsanitize=address -fno-omit-frame-pointer -g -shared-libasan" \
          LDFLAGS="-fsanitize=address -shared-libasan" \
          python3 setup.py build_ext --inplace

      - name: Install pytest
        run: pip install pytest pytest-cov

      - name: Run tests with ASAN
        id: asan
        run: |
          # Find the ASAN runtime library for LD_PRELOAD
          # This is required because the Python binary itself is not ASAN-instrumented
          ASAN_LIB=$(clang -print-file-name=libclang_rt.asan-x86_64.so)

          # If not found with clang, try the shared library path
          if [ ! -f "$ASAN_LIB" ]; then
            ASAN_LIB=$(find /usr -name "libasan.so*" 2>/dev/null | head -1)
          fi

          echo "Using ASAN library: $ASAN_LIB"

          # Run with LD_PRELOAD to load ASAN runtime before Python
          LD_PRELOAD="$ASAN_LIB" \
          ASAN_OPTIONS=detect_leaks=1:symbolize=1:verify_asan_link_order=0 \
          python3 -m pytest asterix/test/test_ffi_security.py -v

      - name: Create issue on failure
        if: failure() && steps.asan.outcome == 'failure'
        uses: actions/github-script@v8
        with:
          script: |
            const title = '[Nightly] ASAN detected memory errors';
            const body = `ASAN scan failed on ${new Date().toISOString().split('T')[0]}.

            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            AddressSanitizer detected memory errors (use-after-free, buffer overflows, etc.) in the Python FFI layer.

            **Priority:** Critical - memory errors can lead to crashes or security vulnerabilities.`;

            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,asan'
            });

            const existingIssue = issues.data.find(i => i.title === title);

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['security', 'python', 'memory-safety', 'asan', 'automated']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `Still failing as of ${new Date().toISOString().split('T')[0]}.\n\n**Latest run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
              });
            }

  rust-fuzzing:
    name: Cargo Fuzz (1 hour)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Install Rust nightly
        uses: dtolnay/rust-toolchain@nightly

      - name: Install cargo-fuzz
        run: cargo install cargo-fuzz

      - name: Initialize fuzz target if needed
        working-directory: asterix-rs
        run: |
          if [ ! -d fuzz ]; then
            cargo fuzz init
            echo "Initialized fuzzing infrastructure"
          fi

      - name: Run fuzzing for 1 hour
        working-directory: asterix-rs
        run: |
          # List available fuzz targets
          targets=$(cargo fuzz list 2>/dev/null || echo "")
          if [ -z "$targets" ]; then
            echo "No fuzz targets found, skipping"
            exit 0
          fi

          # Run first target for 1 hour
          target=$(echo "$targets" | head -1)
          timeout 3600 cargo fuzz run $target -- -max_total_time=3600 || true

      - name: Check for crashes
        id: check_crashes
        working-directory: asterix-rs
        run: |
          # Only look for actual crash files, not slow-units (performance concerns)
          # Crash files typically start with 'crash-', 'oom-', 'timeout-'
          # Slow-units start with 'slow-unit-' and are NOT security issues
          crash_count=0
          if [ -d fuzz/artifacts ]; then
            crash_count=$(find fuzz/artifacts -type f \( -name 'crash-*' -o -name 'oom-*' -o -name 'timeout-*' \) 2>/dev/null | wc -l)
            echo "Found crash artifacts:"
            ls -laR fuzz/artifacts/ || true
          fi

          if [ "$crash_count" -gt 0 ]; then
            echo "crashes_found=true" >> $GITHUB_OUTPUT
            echo "Found $crash_count actual crash artifacts"
          else
            echo "crashes_found=false" >> $GITHUB_OUTPUT
            echo "No crash artifacts found (slow-units are informational only)"
          fi

      - name: Upload crash artifacts
        if: steps.check_crashes.outputs.crashes_found == 'true'
        uses: actions/upload-artifact@v5
        with:
          name: fuzz-crashes
          path: asterix-rs/fuzz/artifacts/

      - name: Create issue on crashes
        if: steps.check_crashes.outputs.crashes_found == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const title = '[Nightly] Fuzzing found crashes';
            const body = `Fuzzer discovered crashes on ${new Date().toISOString().split('T')[0]}.

            **Workflow Run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            Crash artifacts have been uploaded. Download them from the workflow run artifacts section.

            **Priority:** High - fuzzer-found crashes indicate edge cases that could be exploited.`;

            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'automated,fuzzing'
            });

            const existingIssue = issues.data.find(i => i.title === title);

            if (!existingIssue) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['security', 'rust', 'fuzzing', 'automated']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `New crashes found on ${new Date().toISOString().split('T')[0]}.\n\n**Latest run:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
              });
            }
